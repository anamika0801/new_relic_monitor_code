name: Update New Relic Monitor

on:
  workflow_dispatch:
    inputs:
      monitor_guid:
        description: 'GUID of the monitor'
        required: true
      account_id:
        description: 'New Relic Account ID'
        required: true
      api_key_secret_name:
        description: 'GitHub Secret Name for New Relic API Key'
        required: false
        default: NEW_RELIC_API_KEY # Assuming your secret is named this

jobs:
  disable-monitor:
    runs-on: ubuntu-latest
    
   steps:
  - name: Checkout repository
    uses: actions/checkout@v4

  - name: Install JQ (if not available)
    run: sudo apt-get update && sudo apt-get install -y jq

  - name: Update Monitor via NerdGraph
    env:
      NR_API_KEY: ${{ secrets[github.event.inputs.api_key_secret_name] || secrets.NEW_RELIC_API_KEY }}
      MONITOR_GUID: ${{ github.event.inputs.monitor_guid }}
      # Map inputs to env variables
      NEW_STATUS: ${{ github.event.inputs.monitor_status }} 
      NEW_NAME: ${{ github.event.inputs.monitor_name }}
      NEW_PERIOD: ${{ github.event.inputs.monitor_period }}
      
      # This variable holds the entire script content from the previous mutation payload
      MONITOR_SCRIPT: |
        // Anamika wants to Import the 'assert' module for validation var assert = require("assert");  // Define the options for the HTTP request var options = {   url: "https://www.newrelic.com", };  // Define the callback function to handle the response function callback(error, response, body) {   // Log the HTTP status code to the Synthetics console   console.log("Status code: " + response.statusCode);    // Assert that the status code is 200   assert.equal(response.statusCode, 200, "Expected a 200 OK response");    // Log a success message if the test passes   console.log("Monitor finished successfully!"); }  // Make the HTTP GET request $http.get(options, callback);
    
    run: |
      echo "ðŸ”„ Preparing to update the monitor fields for GUID: $MONITOR_GUID"

      if [ -z "$NR_API_KEY" ]; then
        echo "::error::New Relic API Key secret not found."
        exit 1
      fi

      # 1. Define the GraphQL Mutation Payload using JQ
      # This payload is constructed to exactly match the structure in mutation_payload.json
      # Note: The query string uses escaped newlines (\n) to preserve formatting, which JQ handles correctly.
      MUTATION_PAYLOAD=$(jq -n \
        --arg guid "$MONITOR_GUID" \
        --arg status "$NEW_STATUS" \
        --arg name "$NEW_NAME" \
        --arg period "$NEW_PERIOD" \
        --arg script "$MONITOR_SCRIPT" \
        '{
          query: "mutation UpdateSyntheticMonitor($monitorGuid: ID!, $monitorInput: SyntheticsUpdateScriptApiMonitorInput!) {\n  syntheticsUpdateScriptApiMonitor(\n    guid: $monitorGuid\n    monitor: $monitorInput\n  ) {\n    errors {\n      description\n      type\n    }\n    monitor {\n      guid\n      name\n      status\n    }\n  }\n}",
          variables: {
            monitorGuid: $guid,
            monitorInput: {
              status: $status,
              name: $name,
              period: $period,
              script: $script
            }
          }
        }')

      echo "Request Payload:"
      echo "$MUTATION_PAYLOAD" | jq . # Pretty print the payload for debugging

      # 2. Execute the Mutation using curl
      RESPONSE=$(curl -s -X POST https://api.newrelic.com/graphql \
        -H "Content-Type: application/json" \
        -H "API-Key: ${NR_API_KEY}" \
        --data-raw "$MUTATION_PAYLOAD")

      echo "ðŸ“¡ API Response: $RESPONSE"

        # 3. Check for Errors and Confirm Status/Name
      # Check for errors in the `errors` array
      UPDATE_ERRORS=$(echo "$RESPONSE" | jq -r '.data.syntheticsUpdateScriptApiMonitor.errors[]?.description' | tr '\n' ' ')
      
      # Extract the final state of the monitor
      FINAL_STATUS=$(echo "$RESPONSE" | jq -r '.data.syntheticsUpdateScriptApiMonitor.monitor.status')
      FINAL_NAME=$(echo "$RESPONSE" | jq -r '.data.syntheticsUpdateScriptApiMonitor.monitor.name')

      if [ -n "$UPDATE_ERRORS" ] && [ "$UPDATE_ERRORS" != "null" ]; then
        echo "::error::Monitor update failed: $UPDATE_ERRORS"
        exit 1
      elif [ "$FINAL_STATUS" == "$NEW_STATUS" ] && [ "$FINAL_NAME" == "$NEW_NAME" ]; then
        echo "âœ… Monitor $MONITOR_GUID successfully updated. New status: $NEW_STATUS, New name: $NEW_NAME."
        # Optionally output the GUID
        echo "monitor_guid=$MONITOR_GUID" >> $GITHUB_OUTPUT 
      else
        echo "::error::Monitor update failed. Check API response for details."
        exit 1
      fi

