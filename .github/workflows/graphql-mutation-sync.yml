name: New Relic monitor

on:
  workflow_dispatch:  # Manual trigger only

jobs:
  deploy-monitors:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Deploy monitors
        env:
          ALL_SECRETS: ${{ toJSON(secrets) }}
        run: |
          echo "ðŸš€ Starting manual monitor deployment..."

          if [ ! -f monitors/manifest.json ]; then
            echo "::error::Manifest file not found at monitors/manifest.json"
            exit 1
          fi

          jq -r -c '.[]' monitors/manifest.json | while read -r entry; do
            FILE_PATH=$(echo "$entry" | jq -r '.filePath')
            ACCOUNT_ID=$(echo "$entry" | jq -r '.accountId')
            API_KEY_SECRET_NAME=$(echo "$entry" | jq -r '.apiKeySecretName')
            API_KEY=$(echo "$ALL_SECRETS" | jq -r ".\"$API_KEY_SECRET_NAME\"")
            GUID=$(echo "$entry" | jq -r '.guid')

            if [ -z "$API_KEY" ] || [ "$API_KEY" == "null" ]; then
              echo "::error::Secret '$API_KEY_SECRET_NAME' not found in GitHub secrets."
              exit 1
            fi

            if [ ! -f "$FILE_PATH" ]; then
              echo "::error::monitor file '$FILE_PATH' not found."
              exit 1
            fi

            echo "ðŸ“„ Deploying monitor: $FILE_PATH"

            monitor_CONTENT=$(cat "$FILE_PATH")
            echo "$monitor_CONTENT" | jq . > /dev/null
            if [ $? -ne 0 ]; then
              echo "::error::Invalid JSON in $FILE_PATH"
              exit 1
            fi

            # ðŸ§¼ Sanitize monitor JSON
            SANITIZED_monitor=$(echo "$monitor_CONTENT" | jq 'del(.pages[].guid) | .pages[].widgets |= map(del(.id))')

            # ðŸŽ¯ Update existing monitor using monitorUpdate
            if [ -n "$GUID" ] && [ "$GUID" != "null" ]; then
              echo "ðŸ”„ Updating monitor with GUID: $GUID"

              # Create a temporary file to store the GraphQL mutation
              GRAPHQL_FILE=$(mktemp)

              # Prepare the GraphQL mutation JSON and write it to the temporary file
              # We pipe the monitor JSON in via stdin (using '.') to avoid "Argument list too long"
              echo "Fetching monitor details for: $MONITOR_NAME"
          QUERY_PAYLOAD=$(cat <<EOF
          {
            "query": "query GetMonitorDetails { actor { account(id: $NR_ACCOUNT_ID) { synthetics { monitors(query: {name: \"$MONITOR_NAME\"}) { monitors { guid status } } } } } }",
            "variables": {}
          }
          EOF
          )
          
          RESPONSE=$(curl -s -X POST 'https://api.newrelic.com/graphql' \
            -H "Content-Type: application/json" \
            -H "Api-Key: $NR_API_KEY" \
            --data-raw "$QUERY_PAYLOAD")

          # Extract GUID and current STATUS using jq
          MONITOR_GUID=$(echo "$RESPONSE" | jq -r '.data.actor.account.synthetics.monitors.monitors[0].guid')
          CURRENT_STATUS=$(echo "$RESPONSE" | jq -r '.data.actor.account.synthetics.monitors.monitors[0].status')

          if [ -z "$MONITOR_GUID" ] || [ "$MONITOR_GUID" == "null" ]; then
            echo "Error: Monitor named '$MONITOR_NAME' not found or failed to retrieve details."
            exit 1
          fi

          echo "Found monitor GUID: $MONITOR_GUID"
          echo "Current Status: $CURRENT_STATUS"
          
          # --- 2. Logic: Determine the new status ---
          NEW_STATUS=""
          if [ "$CURRENT_STATUS" == "ENABLED" ]; then
            NEW_STATUS="DISABLED"
          elif [ "$CURRENT_STATUS" == "DISABLED" ]; then
            NEW_STATUS="ENABLED"
          else
            echo "Warning: Current status '$CURRENT_STATUS' is unexpected. Setting to ENABLED."
            NEW_STATUS="ENABLED"
          fi
          
          echo "Setting New Status: $NEW_STATUS"
          
          # --- 3. Mutation: Execute the update ---
          MUTATION_PAYLOAD=$(cat <<EOF
          {
            "query": "mutation ToggleMonitorStatus(\$monitorGuid: EntityGuid!, \$newStatus: SyntheticsMonitorStatus!) { syntheticsUpdateScriptApiMonitor(guid: \$monitorGuid, monitor: { status: \$newStatus }) { errors { description type } monitor { guid name status } } }",
            "variables": {
              "monitorGuid": "$MONITOR_GUID",
              "newStatus": "$NEW_STATUS"
            }
          }
          EOF
          ) > "$GRAPHQL_FILE"

              # Send the GraphQL request using curl and the temporary file
              RESPONSE=$(curl -s -X POST https://api.newrelic.com/graphql \
                -H "Content-Type: application/json" \
                -H "API-Key: ${API_KEY}" \
                --data-binary "@$GRAPHQL_FILE")

              # Clean up the temporary file
              rm "$GRAPHQL_FILE"

              echo "ðŸ“¡ API Response: $RESPONSE"

              # ðŸš¨ Error checks

              # Top-level GraphQL errors
              TOP_LEVEL_ERRORS=$(echo "$RESPONSE" | jq -r '.errors[]?.message')
              if [ "$TOP_LEVEL_ERRORS" != "null" ] && [ -n "$TOP_LEVEL_ERRORS" ]; then
                echo "::error::GraphQL top-level error for $FILE_PATH: $TOP_LEVEL_ERRORS"
                exit 1
              fi

              # Errors inside monitorUpdate
              UPDATE_ERRORS=$(echo "$RESPONSE" | jq -r '.data.monitorUpdate.errors[]?.description')
              if [ "$UPDATE_ERRORS" != "null" ] && [ -n "$UPDATE_ERRORS" ]; then
                echo "::error::monitor update failed for $FILE_PATH: $UPDATE_ERRORS"
                exit 1
              fi

              # Null monitorUpdate (unexpected)
              monitor_UPDATE_NULL=$(echo "$RESPONSE" | jq -r '.data.monitorUpdate == null')
              if [ "$monitor_UPDATE_NULL" == "true" ]; then
                echo "::error::monitor update failed for $FILE_PATH: monitorUpdate returned null"
                exit 1
              fi

              echo "âœ… monitor updated successfully."

            else
              echo "::warning::No GUID provided. Skipping update for $FILE_PATH."
            fi

            echo "-------------------------------------------------------------"
          done

          echo "ðŸŽ‰ monitor deployment complete!"
